
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>diz.flow</title>
<link href="https://fonts.googleapis.com/css2?family=DM+Sans:wght@400;500;600&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
<style>
  :root {
    --bg: #0e0e12;
    --surface: #18181f;
    --surface-2: #22222c;
    --border: #2a2a36;
    --text: #e4e4ed;
    --text-dim: #7a7a8e;
    --accent: #6c5ce7;
    --accent-light: #a29bfe;
    --green: #00b894;
    --red: #e17055;
  }
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body {
    font-family: 'DM Sans', sans-serif;
    background: var(--bg);
    color: var(--text);
    height: 100vh;
    overflow: hidden;
    display: flex;
    flex-direction: column;
  }
  header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 10px 20px;
    background: var(--surface);
    border-bottom: 1px solid var(--border);
    z-index: 200;
  }
  .logo {
    font-family: 'JetBrains Mono', monospace;
    font-weight: 500; font-size: 15px;
    letter-spacing: -0.5px; color: var(--accent-light);
  }
  .logo span { color: var(--text-dim); }
  .toolbar { display: flex; align-items: center; gap: 8px; }
  .status-pill {
    display: flex; align-items: center; gap: 6px;
    padding: 5px 12px; border-radius: 20px; font-size: 12px; font-weight: 500;
    background: var(--surface-2); border: 1px solid var(--border);
    color: var(--text-dim); font-family: 'JetBrains Mono', monospace;
  }
  .status-pill .dot { width: 8px; height: 8px; border-radius: 50%; background: var(--text-dim); flex-shrink: 0; }
  .status-pill.active .dot { background: var(--green); }
  .status-pill.active { color: var(--green); border-color: rgba(0,184,148,0.3); }
  .btn {
    padding: 6px 14px; border-radius: 6px; font-size: 12px; font-weight: 500;
    font-family: 'DM Sans', sans-serif; border: 1px solid var(--border);
    background: var(--surface-2); color: var(--text); cursor: pointer; transition: all 0.15s;
  }
  .btn:hover { background: var(--border); }
  .btn.primary { background: var(--accent); border-color: var(--accent); color: #fff; }
  .btn.primary:hover { background: #5a4bd6; }
  .btn.danger { color: var(--red); }
  .btn.danger:hover { background: rgba(225,112,85,0.1); }

  /* ── Infinite canvas ── */
  .canvas-area {
    flex: 1; position: relative; overflow: hidden; cursor: grab;
    background: var(--bg);
  }
  .canvas-area.grabbing { cursor: grabbing; }
  .canvas-area.drawing { cursor: crosshair; }

  /* Dot grid rendered by JS on a background canvas */
  #gridCanvas {
    position: absolute; top: 0; left: 0; width: 100%; height: 100%;
    pointer-events: none; z-index: 0;
  }

  #worldLayer {
    position: absolute; top: 0; left: 0;
    transform-origin: 0 0;
    z-index: 1;
  }

  .screen-img {
    position: absolute;
    border-radius: 8px;
    box-shadow: 0 4px 30px rgba(0,0,0,0.6);
    user-select: none;
    -webkit-user-drag: none;
    -webkit-touch-callout: none;
    cursor: move;
    transition: box-shadow 0.2s;
  }
  .screen-img:hover { box-shadow: 0 4px 40px rgba(0,0,0,0.8); }
  .screen-img.dragging { opacity: 0.85; box-shadow: 0 8px 50px rgba(0,0,0,0.9); z-index: 999; }

  #annotationSVG {
    position: absolute; top: 0; left: 0;
    width: 1px; height: 1px;
    overflow: visible;
    pointer-events: none;
    z-index: 10;
  }
  #annotationSVG .draw-layer { pointer-events: all; }

  /* Upload overlay */
  .upload-overlay {
    position: absolute; top: 0; left: 0; right: 0; bottom: 0;
    display: flex; align-items: center; justify-content: center;
    z-index: 100; pointer-events: none;
  }
  .upload-overlay.active { pointer-events: all; }
  .upload-zone {
    display: flex; flex-direction: column; align-items: center; gap: 16px;
    padding: 50px 70px; border: 2px dashed var(--border); border-radius: 16px;
    cursor: pointer; transition: all 0.2s;
    background: rgba(14,14,18,0.9); backdrop-filter: blur(10px);
  }
  .upload-zone:hover { border-color: var(--accent); background: rgba(108,92,231,0.08); }
  .upload-zone svg { opacity: 0.4; }
  .upload-zone:hover svg { opacity: 0.7; }
  .upload-zone h3 { font-size: 16px; font-weight: 500; }
  .upload-zone p { font-size: 13px; color: var(--text-dim); }
  #fileInput { display: none; }

  .instructions-bar {
    position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%);
    display: flex; align-items: center; gap: 10px;
    padding: 10px 20px; background: var(--surface); border: 1px solid var(--border);
    border-radius: 12px; font-size: 13px; color: var(--text-dim);
    backdrop-filter: blur(12px); box-shadow: 0 4px 24px rgba(0,0,0,0.4);
    z-index: 150; white-space: nowrap;
    transition: opacity 0.4s, transform 0.4s;
    opacity: 1; pointer-events: auto;
  }
  .instructions-bar.hidden {
    opacity: 0; pointer-events: none;
    transform: translateX(-50%) translateY(10px);
  }
  .instructions-bar .sep { width: 1px; height: 16px; background: var(--border); }
  .step-counter {
    font-family: 'JetBrains Mono', monospace; font-size: 12px;
    display: flex; align-items: center; gap: 6px;
  }
  .flow-dot { width: 8px; height: 8px; border-radius: 50%; display: inline-block; }

  .label-input-wrapper {
    position: fixed; z-index: 300;
    display: none; flex-direction: row; align-items: center; gap: 4px;
  }
  .label-input-wrapper.visible { display: flex; }
  .label-input {
    padding: 4px 8px; font-family: 'JetBrains Mono', monospace; font-size: 12px;
    background: var(--surface); border: 1px solid var(--accent); border-radius: 4px;
    color: var(--text); outline: none; min-width: 80px;
  }
  .label-confirm-btn {
    padding: 4px 10px; font-family: 'JetBrains Mono', monospace; font-size: 12px;
    background: var(--accent); border: none; border-radius: 4px;
    color: #fff; cursor: pointer; white-space: nowrap;
  }

  /* About modal */
  .modal-backdrop {
    position: fixed; inset: 0; background: rgba(0,0,0,0.6);
    backdrop-filter: blur(4px); z-index: 500;
    display: flex; align-items: center; justify-content: center;
    opacity: 0; pointer-events: none; transition: opacity 0.25s;
  }
  .modal-backdrop.open { opacity: 1; pointer-events: all; }
  .modal {
    background: var(--surface); border: 1px solid var(--border);
    border-radius: 14px; padding: 32px 36px; max-width: 420px; width: 90vw;
    box-shadow: 0 20px 60px rgba(0,0,0,0.5);
    transform: translateY(10px); transition: transform 0.25s;
  }
  .modal-backdrop.open .modal { transform: translateY(0); }
  .modal h2 {
    font-family: 'JetBrains Mono', monospace; font-size: 20px;
    font-weight: 500; margin-bottom: 12px; color: var(--accent-light);
  }
  .modal h2 span { color: var(--text-dim); }
  .modal p { font-size: 14px; line-height: 1.6; color: var(--text-dim); margin-bottom: 10px; }
  .modal .features { margin: 16px 0; }
  .modal .features p { margin-bottom: 6px; font-size: 13px; }
  .modal .made-by {
    margin-top: 20px; padding-top: 16px; border-top: 1px solid var(--border);
    font-size: 13px; color: var(--text-dim);
    display: flex; align-items: center; gap: 6px;
  }
  .modal .made-by a {
    color: var(--accent-light); text-decoration: none; font-weight: 500;
  }
  .modal .made-by a:hover { text-decoration: underline; }
  .modal .made-by img {
    width: 18px; height: 18px; border-radius: 3px;
    vertical-align: middle; display: inline-block;
  }
  .modal-close {
    position: absolute; top: 14px; right: 14px;
    background: none; border: none; color: var(--text-dim);
    font-size: 20px; cursor: pointer; line-height: 1;
    padding: 4px 8px; border-radius: 4px;
  }
  .modal-close:hover { background: var(--surface-2); color: var(--text); }

  .mode-toggle {
    display: flex; border-radius: 6px; overflow: hidden; border: 1px solid var(--border);
  }
  .mode-toggle button {
    padding: 5px 12px; font-size: 11px; font-weight: 500;
    font-family: 'JetBrains Mono', monospace;
    border: none; background: var(--surface-2); color: var(--text-dim);
    cursor: pointer; transition: all 0.15s;
  }
  .mode-toggle button.active {
    background: var(--accent); color: #fff;
  }
  .mode-toggle button:hover:not(.active) { background: var(--border); }

  @media (max-width: 640px) {
    header { padding: 8px 12px; }
    .logo { font-size: 13px; }
    .toolbar { gap: 4px; flex-wrap: wrap; justify-content: flex-end; }
    .btn { padding: 5px 10px; font-size: 11px; }
    .status-pill { padding: 4px 8px; font-size: 11px; }
    .instructions-bar {
      bottom: 10px; padding: 8px 12px; font-size: 11px; gap: 6px;
      max-width: 95vw; white-space: normal; text-align: center;
      flex-wrap: wrap; justify-content: center;
    }
  }
</style>
</head>
<body>

<header>
  <div class="logo">diz<span>.flow</span></div>
  <div class="toolbar">
    <div class="status-pill" id="statusPill">
      <div class="dot" id="statusDot"></div>
      <span id="statusText">Add images</span>
    </div>
    <div class="mode-toggle" id="modeToggle" style="display:none">
      <button id="modeMoveBtn" class="active" onclick="setMode('move')">Move</button>
      <button id="modeDrawBtn" onclick="setMode('draw')">Draw</button>
    </div>
    <button class="btn" id="addBtn" onclick="document.getElementById('fileInput').click()">+ Image</button>
    <button class="btn danger" id="clearBtn" style="display:none" onclick="clearAll()">Clear</button>
    <button class="btn primary" id="copyBtn" style="display:none" onclick="copyToClipboard()">Copy</button>
    <button class="btn primary" id="exportBtn" style="display:none" onclick="exportImage()">Export</button>
    <button class="btn" onclick="document.getElementById('aboutModal').classList.add('open')">About</button>
  </div>
</header>

<div class="modal-backdrop" id="aboutModal" onclick="if(event.target===this)this.classList.remove('open')">
  <div class="modal" style="position:relative">
    <button class="modal-close" onclick="document.getElementById('aboutModal').classList.remove('open')">&times;</button>
    <h2>diz<span>.flow</span></h2>
    <p>A lightweight screenshot annotation tool for creating user flow diagrams. Upload screenshots, arrange them on an infinite canvas, and draw connected bounding boxes to map out user journeys.</p>
    <div class="features">
      <p><strong style="color:var(--text)">Multi-image canvas</strong> — upload and position multiple screenshots freely</p>
      <p><strong style="color:var(--text)">Color-coded flows</strong> — each flow gets a unique color, press Esc to start the next</p>
      <p><strong style="color:var(--text)">Infinite canvas</strong> — scroll to pan, pinch to zoom, middle-click to drag</p>
      <p><strong style="color:var(--text)">Export</strong> — copy to clipboard or download as PNG</p>
    </div>
    <div class="made-by">
      Made by&nbsp;<a href="https://dizzard.net" target="_blank">Diz</a>&nbsp;<img src="https://raw.githubusercontent.com/momja/momja.github.io/master/favicon/32x32.png" alt="diz" onerror="this.style.display='none'">
    </div>
  </div>
</div>

<div class="canvas-area" id="canvasArea">
  <canvas id="gridCanvas"></canvas>
  <div id="worldLayer">
    <svg id="annotationSVG">
      <defs></defs>
      <g class="draw-layer" id="drawLayer"></g>
    </svg>
  </div>

  <div class="upload-overlay active" id="uploadOverlay">
    <div class="upload-zone" onclick="document.getElementById('fileInput').click()">
      <svg width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
        <rect x="3" y="3" width="18" height="18" rx="2"/>
        <circle cx="8.5" cy="8.5" r="1.5"/>
        <path d="m21 15-5-5L5 21"/>
      </svg>
      <h3>Drop screenshots here</h3>
      <p>Upload multiple images — arrange them on the canvas</p>
    </div>
  </div>

  <input type="file" id="fileInput" accept="image/*" multiple>
</div>

<div class="instructions-bar hidden" id="instructionsBar">
  <span class="step-counter" id="stepCounter"></span>
  <div class="sep"></div>
  <span id="instructionText"></span>
</div>

<div class="label-input-wrapper" id="labelInputWrapper">
  <input class="label-input" id="labelInput" placeholder="Label..." maxlength="30">
  <button class="label-confirm-btn" id="labelConfirmBtn">OK</button>
</div>

<script>
// ── Colors ──
const FLOW_COLORS = [
  { stroke: '#6c5ce7', light: '#a29bfe', fill: 'rgba(108,92,231,0.10)', glow: 'rgba(108,92,231,0.45)' },
  { stroke: '#00b894', light: '#55efc4', fill: 'rgba(0,184,148,0.10)',  glow: 'rgba(0,184,148,0.45)' },
  { stroke: '#e17055', light: '#fab1a0', fill: 'rgba(225,112,85,0.10)', glow: 'rgba(225,112,85,0.45)' },
  { stroke: '#fdcb6e', light: '#ffeaa7', fill: 'rgba(253,203,110,0.10)',glow: 'rgba(253,203,110,0.40)' },
  { stroke: '#0984e3', light: '#74b9ff', fill: 'rgba(9,132,227,0.10)',  glow: 'rgba(9,132,227,0.45)' },
  { stroke: '#e84393', light: '#fd79a8', fill: 'rgba(232,67,147,0.10)', glow: 'rgba(232,67,147,0.45)' },
  { stroke: '#00cec9', light: '#81ecec', fill: 'rgba(0,206,201,0.10)',  glow: 'rgba(0,206,201,0.45)' },
  { stroke: '#d63031', light: '#ff7675', fill: 'rgba(214,48,49,0.10)',  glow: 'rgba(214,48,49,0.45)' },
];

// ── State ──
const cam = { x: 0, y: 0, zoom: 1 };
const images = []; // {el, x, y, w, h, naturalW, naturalH, dataUrl}
const state = {
  flows: [],
  currentFlowIndex: -1,
  drawing: false,
  startX: 0, startY: 0,
  phase: 'idle',
  tempBox: null,
  history: [],
  mode: 'move', // 'move' | 'draw'
};

function curFlow() { return state.flows[state.currentFlowIndex] || null; }
function flowCol(flow) { return FLOW_COLORS[flow.colorIndex % FLOW_COLORS.length]; }
function curCol() { const f = curFlow(); return f ? flowCol(f) : FLOW_COLORS[0]; }

// ── DOM ──
const canvasArea = document.getElementById('canvasArea');
const gridCanvas = document.getElementById('gridCanvas');
const gridCtx = gridCanvas.getContext('2d');
const worldLayer = document.getElementById('worldLayer');
const annotationSVG = document.getElementById('annotationSVG');
const drawLayer = document.getElementById('drawLayer');
const uploadOverlay = document.getElementById('uploadOverlay');
const fileInput = document.getElementById('fileInput');
const instructionsBar = document.getElementById('instructionsBar');
const stepCounter = document.getElementById('stepCounter');
const instructionText = document.getElementById('instructionText');
const statusDot = document.getElementById('statusDot');
const statusTextEl = document.getElementById('statusText');
const statusPill = document.getElementById('statusPill');
const labelInput = document.getElementById('labelInput');
const labelInputWrapper = document.getElementById('labelInputWrapper');
const labelConfirmBtn = document.getElementById('labelConfirmBtn');
const modeToggle = document.getElementById('modeToggle');

// ── Grid ──
function drawGrid() {
  const dpr = window.devicePixelRatio || 1;
  const w = canvasArea.clientWidth;
  const h = canvasArea.clientHeight;
  gridCanvas.width = w * dpr;
  gridCanvas.height = h * dpr;
  gridCtx.setTransform(dpr, 0, 0, dpr, 0, 0);
  gridCtx.clearRect(0, 0, w, h);

  const spacing = 40 * cam.zoom;
  if (spacing < 8) return; // too dense

  const offsetX = (cam.x * cam.zoom) % spacing;
  const offsetY = (cam.y * cam.zoom) % spacing;
  const dotSize = Math.max(1, 1.2 * cam.zoom);
  const alpha = Math.min(1, (spacing - 8) / 20) * 0.25;

  gridCtx.fillStyle = `rgba(255,255,255,${alpha})`;
  for (let x = offsetX; x < w; x += spacing) {
    for (let y = offsetY; y < h; y += spacing) {
      gridCtx.beginPath();
      gridCtx.arc(x, y, dotSize, 0, Math.PI * 2);
      gridCtx.fill();
    }
  }
}

function updateWorldTransform() {
  worldLayer.style.transform = `translate(${cam.x * cam.zoom}px, ${cam.y * cam.zoom}px) scale(${cam.zoom})`;
  drawGrid();
}

// ── Pan & Zoom ──
let isPanning = false;
let panStartX, panStartY, camStartX, camStartY;

// Prevent default middle-click autoscroll
canvasArea.addEventListener('auxclick', (e) => { if (e.button === 1) e.preventDefault(); });

// Middle mouse button — capture phase so it fires before image drag handlers
window.addEventListener('mousedown', (e) => {
  if (e.button === 1) {
    e.preventDefault();
    isPanning = true;
    panStartX = e.clientX; panStartY = e.clientY;
    camStartX = cam.x; camStartY = cam.y;
    canvasArea.classList.add('grabbing');
  }
}, true);

canvasArea.addEventListener('wheel', (e) => {
  e.preventDefault();
  if (e.ctrlKey || e.metaKey) {
    const rect = canvasArea.getBoundingClientRect();
    const mx = e.clientX - rect.left;
    const my = e.clientY - rect.top;
    const worldX = mx / cam.zoom - cam.x;
    const worldY = my / cam.zoom - cam.y;
    const delta = -e.deltaY * 0.005;
    const newZoom = Math.max(0.1, Math.min(5, cam.zoom * (1 + delta)));
    cam.x = mx / newZoom - worldX;
    cam.y = my / newZoom - worldY;
    cam.zoom = newZoom;
  } else {
    cam.x -= e.deltaX / cam.zoom;
    cam.y -= e.deltaY / cam.zoom;
  }
  updateWorldTransform();
}, { passive: false });

// Left-click pan in move mode (only on empty canvas)
canvasArea.addEventListener('mousedown', (e) => {
  if (e.button !== 0) return;
  if (state.mode === 'draw') return;
  if (e.target !== canvasArea && e.target !== gridCanvas) return;
  isPanning = true;
  panStartX = e.clientX; panStartY = e.clientY;
  camStartX = cam.x; camStartY = cam.y;
  canvasArea.classList.add('grabbing');
});

window.addEventListener('mousemove', (e) => {
  if (!isPanning) return;
  cam.x = camStartX + (e.clientX - panStartX) / cam.zoom;
  cam.y = camStartY + (e.clientY - panStartY) / cam.zoom;
  updateWorldTransform();
});

window.addEventListener('mouseup', (e) => {
  if (isPanning) {
    isPanning = false;
    canvasArea.classList.remove('grabbing');
  }
});

// Touch pan
let touchPanning = false;
let touchStartX, touchStartY, touchCamX, touchCamY;

canvasArea.addEventListener('touchstart', (e) => {
  if (state.mode === 'draw' || e.touches.length !== 1) return;
  const t = e.target;
  if (t.classList.contains('screen-img')) return;
  touchPanning = true;
  touchStartX = e.touches[0].clientX; touchStartY = e.touches[0].clientY;
  touchCamX = cam.x; touchCamY = cam.y;
}, { passive: true });

window.addEventListener('touchmove', (e) => {
  if (!touchPanning || e.touches.length !== 1) return;
  cam.x = touchCamX + (e.touches[0].clientX - touchStartX) / cam.zoom;
  cam.y = touchCamY + (e.touches[0].clientY - touchStartY) / cam.zoom;
  updateWorldTransform();
}, { passive: true });

window.addEventListener('touchend', () => { touchPanning = false; });

// ── Image upload ──
fileInput.addEventListener('change', (e) => {
  if (e.target.files) {
    Array.from(e.target.files).forEach(f => loadImage(f));
    fileInput.value = '';
  }
});

document.addEventListener('paste', (e) => {
  if (state.phase === 'label') return;
  const items = e.clipboardData && e.clipboardData.items;
  if (!items) return;
  for (const item of items) {
    if (item.type.startsWith('image/')) {
      e.preventDefault();
      loadImage(item.getAsFile());
      return;
    }
  }
});

canvasArea.addEventListener('dragover', (e) => e.preventDefault());
canvasArea.addEventListener('drop', (e) => {
  e.preventDefault();
  if (e.dataTransfer.files) {
    Array.from(e.dataTransfer.files).forEach(f => {
      if (f.type.startsWith('image/')) loadImage(f);
    });
  }
});

function loadImage(file) {
  const reader = new FileReader();
  reader.onload = (evt) => {
    const dataUrl = evt.target.result;
    const tmp = new Image();
    tmp.onload = () => {
      const maxDim = 2400;
      let w = tmp.naturalWidth, h = tmp.naturalHeight;
      if (w > maxDim || h > maxDim) {
        const s = maxDim / Math.max(w, h); w = Math.round(w * s); h = Math.round(h * s);
      }
      const oc = document.createElement('canvas');
      oc.width = w; oc.height = h;
      oc.getContext('2d').drawImage(tmp, 0, 0, w, h);
      const normalizedUrl = oc.toDataURL('image/png');
      addImageToCanvas(normalizedUrl, w, h);
    };
    tmp.onerror = () => addImageToCanvas(dataUrl, 400, 300);
    tmp.src = dataUrl;
  };
  reader.readAsDataURL(file);
}

function addImageToCanvas(dataUrl, natW, natH) {
  // Display size — scale down for canvas
  const maxDisplay = 500;
  let dispW = natW, dispH = natH;
  if (dispW > maxDisplay || dispH > maxDisplay) {
    const s = maxDisplay / Math.max(dispW, dispH);
    dispW = Math.round(dispW * s); dispH = Math.round(dispH * s);
  }

  // Position: offset from camera center, staggered by count
  const areaRect = canvasArea.getBoundingClientRect();
  const centerWorldX = -cam.x + (areaRect.width / 2) / cam.zoom;
  const centerWorldY = -cam.y + (areaRect.height / 2) / cam.zoom;
  const offset = images.length * 40;
  const posX = centerWorldX - dispW / 2 + offset;
  const posY = centerWorldY - dispH / 2 + offset;

  const el = document.createElement('img');
  el.src = dataUrl;
  el.className = 'screen-img';
  el.draggable = false;
  el.style.left = posX + 'px';
  el.style.top = posY + 'px';
  el.style.width = dispW + 'px';
  el.style.height = dispH + 'px';

  const imgData = { el, x: posX, y: posY, w: dispW, h: dispH, naturalW: natW, naturalH: natH, dataUrl };
  images.push(imgData);
  worldLayer.insertBefore(el, annotationSVG);

  // Respect current mode
  el.style.pointerEvents = state.mode === 'draw' ? 'none' : 'auto';

  // Drag to reposition
  setupImageDrag(el, imgData);

  // Hide upload overlay, show controls
  uploadOverlay.style.display = 'none';
  ['clearBtn','copyBtn','exportBtn'].forEach(id => document.getElementById(id).style.display = '');
  modeToggle.style.display = '';

  if (state.flows.length === 0) {
    setMode('draw');
    startNewFlow();
  }

  setStatus('active', `${images.length} image${images.length > 1 ? 's' : ''}`, null);
  showMsg(`Image added — switch to Draw mode to annotate`, null, null);
}

function setupImageDrag(el, imgData) {
  let dragging = false, startMX, startMY, startIX, startIY;

  function onDown(e) {
    if (state.mode !== 'move') return;
    // Only left-click drags images; middle-click should pan
    if (e.button && e.button !== 0) return;
    e.stopPropagation();
    e.preventDefault();
    dragging = true;
    const pt = getClientPos(e);
    startMX = pt.x; startMY = pt.y;
    startIX = imgData.x; startIY = imgData.y;
    el.classList.add('dragging');
  }

  function onMove(e) {
    if (!dragging) return;
    const pt = getClientPos(e);
    imgData.x = startIX + (pt.x - startMX) / cam.zoom;
    imgData.y = startIY + (pt.y - startMY) / cam.zoom;
    el.style.left = imgData.x + 'px';
    el.style.top = imgData.y + 'px';
  }

  function onUp() {
    if (!dragging) return;
    dragging = false;
    el.classList.remove('dragging');
  }

  el.addEventListener('mousedown', onDown);
  window.addEventListener('mousemove', onMove);
  window.addEventListener('mouseup', onUp);
  el.addEventListener('touchstart', (e) => { if (state.mode === 'move' && e.touches.length === 1) onDown(e); }, { passive: false });
  window.addEventListener('touchmove', (e) => { if (dragging && e.touches.length === 1) onMove(e); }, { passive: true });
  window.addEventListener('touchend', onUp);
}

function getClientPos(e) {
  if (e.touches && e.touches.length) return { x: e.touches[0].clientX, y: e.touches[0].clientY };
  if (e.changedTouches && e.changedTouches.length) return { x: e.changedTouches[0].clientX, y: e.changedTouches[0].clientY };
  return { x: e.clientX, y: e.clientY };
}

// ── Mode toggle ──
function setMode(mode) {
  state.mode = mode;
  document.getElementById('modeMoveBtn').classList.toggle('active', mode === 'move');
  document.getElementById('modeDrawBtn').classList.toggle('active', mode === 'draw');
  canvasArea.classList.toggle('drawing', mode === 'draw');

  // In draw mode, images should not capture pointer events
  images.forEach(im => {
    im.el.style.pointerEvents = mode === 'draw' ? 'none' : 'auto';
  });

  if (mode === 'draw') {
    if (state.flows.length === 0 || state.phase === 'idle') {
      startNewFlow();
    }
    showMsg('Click & drag to draw boxes — Esc for next flow', state.currentFlowIndex + 1, curCol());
  } else {
    showMsg('Drag images to reposition — scroll to pan', null, null);
  }
}

// ── Flow lifecycle ──
function startNewFlow() {
  if (state.phase === 'label') commitCurrentLabel();
  saveHistory();
  state.flows.push({ boxes: [], arrows: [], colorIndex: state.flows.length % FLOW_COLORS.length });
  state.currentFlowIndex = state.flows.length - 1;
  state.phase = 'box';
  renderAnnotations();
  updateUI();
}

function finishCurrentFlow() {
  if (state.phase === 'label') commitCurrentLabel();
  // Auto-start new flow
  state.flows.push({ boxes: [], arrows: [], colorIndex: state.flows.length % FLOW_COLORS.length });
  state.currentFlowIndex = state.flows.length - 1;
  state.phase = 'box';
  renderAnnotations();
  updateUI();
}

function commitCurrentLabel() {
  const flow = curFlow();
  if (!flow || flow.boxes.length === 0) return;
  const i = flow.boxes.length - 1;
  flow.boxes[i].label = labelInput.value.trim() || `Step ${i + 1}`;
  labelInputWrapper.classList.remove('visible');
  state.phase = 'box';
  labelInput.onkeydown = null;
  labelConfirmBtn.onclick = null;
}

// ── Instructions ──
let hideTimer = null;
function showMsg(text, flowNum, col) {
  clearTimeout(hideTimer);
  const dotHTML = col ? `<span class="flow-dot" style="background:${col.stroke}"></span>` : '';
  stepCounter.innerHTML = flowNum != null ? `${dotHTML} Flow ${flowNum}` : '';
  instructionText.textContent = text;
  instructionsBar.classList.remove('hidden');
  hideTimer = setTimeout(() => instructionsBar.classList.add('hidden'), 5000);
}

function setStatus(type, text, color) {
  statusPill.className = 'status-pill' + (type === 'active' ? ' active' : '');
  statusTextEl.textContent = text;
  statusDot.style.background = color || '';
}

function updateUI() {
  const flow = curFlow();
  if (!flow) return;
  const col = flowCol(flow);
  const fn = state.currentFlowIndex + 1;

  if (state.phase === 'label') {
    showMsg('Type a label, then Enter or OK', fn, col);
    setStatus('active', `Flow ${fn}`, col.stroke);
  } else {
    const n = flow.boxes.length;
    showMsg(n === 0 ? 'Click & drag to draw a box — Esc for next flow' : 'Click & drag for next box — Esc for next flow', fn, col);
    setStatus('active', `Flow ${fn}`, col.stroke);
  }
}

// ── Screen-to-world coords ──
function screenToWorld(clientX, clientY) {
  const rect = canvasArea.getBoundingClientRect();
  return {
    x: (clientX - rect.left) / cam.zoom - cam.x,
    y: (clientY - rect.top) / cam.zoom - cam.y,
  };
}

function worldToScreen(wx, wy) {
  const rect = canvasArea.getBoundingClientRect();
  return {
    x: (wx + cam.x) * cam.zoom + rect.left,
    y: (wy + cam.y) * cam.zoom + rect.top,
  };
}

// ── Drawing on infinite canvas ──
drawLayer.addEventListener('mousedown', onDrawStart);
drawLayer.addEventListener('touchstart', onDrawStart, { passive: false });
window.addEventListener('mousemove', onDrawMove);
window.addEventListener('touchmove', onDrawMove, { passive: false });
window.addEventListener('mouseup', onDrawEnd);
window.addEventListener('touchend', onDrawEnd, { passive: false });

// We need draw mode to capture clicks anywhere on the canvas area
canvasArea.addEventListener('mousedown', (e) => {
  if (state.mode !== 'draw' || state.phase !== 'box') return;
  // Don't capture if clicking on toolbar or label input
  if (e.target.closest('header') || e.target.closest('.label-input-wrapper')) return;
  onDrawStart(e);
});

canvasArea.addEventListener('touchstart', (e) => {
  if (state.mode !== 'draw' || state.phase !== 'box') return;
  if (e.target.closest('header') || e.target.closest('.label-input-wrapper')) return;
  onDrawStart(e);
}, { passive: false });

function onDrawStart(e) {
  if (state.mode !== 'draw' || state.phase !== 'box') return;
  // Only left mouse button
  if (e.button && e.button !== 0) return;
  e.preventDefault();
  e.stopPropagation();
  const pt = getClientPos(e);
  const world = screenToWorld(pt.x, pt.y);
  state.drawing = true;
  state.startX = world.x; state.startY = world.y;

  const col = curCol();
  state.tempBox = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
  state.tempBox.setAttribute('fill', col.fill);
  state.tempBox.setAttribute('stroke', col.light);
  state.tempBox.setAttribute('stroke-width', 2 / cam.zoom);
  state.tempBox.setAttribute('stroke-dasharray', `${6/cam.zoom} ${3/cam.zoom}`);
  state.tempBox.setAttribute('rx', 4 / cam.zoom);
  state.tempBox.setAttribute('x', world.x); state.tempBox.setAttribute('y', world.y);
  state.tempBox.setAttribute('width', 0); state.tempBox.setAttribute('height', 0);
  drawLayer.appendChild(state.tempBox);
}

function onDrawMove(e) {
  if (!state.drawing || !state.tempBox) return;
  e.preventDefault();
  const pt = getClientPos(e);
  const world = screenToWorld(pt.x, pt.y);
  state.tempBox.setAttribute('x', Math.min(state.startX, world.x));
  state.tempBox.setAttribute('y', Math.min(state.startY, world.y));
  state.tempBox.setAttribute('width', Math.abs(world.x - state.startX));
  state.tempBox.setAttribute('height', Math.abs(world.y - state.startY));
}

function onDrawEnd(e) {
  if (!state.drawing || !state.tempBox) return;
  state.drawing = false;

  const x = +state.tempBox.getAttribute('x');
  const y = +state.tempBox.getAttribute('y');
  const w = +state.tempBox.getAttribute('width');
  const h = +state.tempBox.getAttribute('height');
  if (state.tempBox.parentNode) state.tempBox.parentNode.removeChild(state.tempBox);
  state.tempBox = null;

  if (w < 5 / cam.zoom || h < 5 / cam.zoom) return;

  saveHistory();
  const flow = curFlow();
  const idx = flow.boxes.length;
  flow.boxes.push({ x, y, w, h, label: `${idx + 1}` });
  if (idx > 0) flow.arrows.push({ from: idx - 1, to: idx });

  renderAnnotations();
  showLabelInput(flow, idx, x, y);
}

// ── Label input (positioned in screen space) ──
function showLabelInput(flow, boxIndex, worldX, worldY) {
  state.phase = 'label';
  const col = flowCol(flow);
  const screen = worldToScreen(worldX, worldY);

  labelInputWrapper.classList.add('visible');
  labelInputWrapper.style.left = (screen.x + 4) + 'px';
  labelInputWrapper.style.top = (screen.y + 4) + 'px';
  labelInput.value = '';
  labelInput.placeholder = `Step ${boxIndex + 1}`;
  labelInput.style.borderColor = col.stroke;
  labelInput.style.boxShadow = `0 2px 12px ${col.glow}`;
  labelConfirmBtn.style.background = col.stroke;
  labelInput.focus();
  updateUI();

  function confirm() {
    flow.boxes[boxIndex].label = labelInput.value.trim() || `Step ${boxIndex + 1}`;
    labelInputWrapper.classList.remove('visible');
    state.phase = 'box';
    labelInput.onkeydown = null;
    labelConfirmBtn.onclick = null;
    renderAnnotations();
    updateUI();
  }

  labelInput.onkeydown = (e) => {
    if (e.key === 'Enter') { e.preventDefault(); e.stopPropagation(); confirm(); }
    else if (e.key === 'Escape') {
      e.stopPropagation();
      flow.boxes[boxIndex].label = `Step ${boxIndex + 1}`;
      labelInputWrapper.classList.remove('visible');
      labelInput.onkeydown = null; labelConfirmBtn.onclick = null;
      renderAnnotations();
      finishCurrentFlow();
    }
  };
  labelConfirmBtn.onclick = confirm;
}

// ── Render annotations ──
function renderAnnotations() {
  while (drawLayer.firstChild) drawLayer.removeChild(drawLayer.firstChild);

  const defs = annotationSVG.querySelector('defs');
  defs.innerHTML = '';
  FLOW_COLORS.forEach((col, i) => {
    const m = document.createElementNS('http://www.w3.org/2000/svg', 'marker');
    m.setAttribute('id', `ah-${i}`);
    m.setAttribute('markerWidth', '10'); m.setAttribute('markerHeight', '7');
    m.setAttribute('refX', '9'); m.setAttribute('refY', '3.5');
    m.setAttribute('orient', 'auto'); m.setAttribute('fill', col.light);
    const p = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
    p.setAttribute('points', '0 0, 10 3.5, 0 7');
    m.appendChild(p); defs.appendChild(m);

    // Glow filter
    const filter = document.createElementNS('http://www.w3.org/2000/svg', 'filter');
    filter.setAttribute('id', `glow-${i}`);
    filter.setAttribute('x', '-25%'); filter.setAttribute('y', '-25%');
    filter.setAttribute('width', '150%'); filter.setAttribute('height', '150%');
    const feGauss = document.createElementNS('http://www.w3.org/2000/svg', 'feGaussianBlur');
    feGauss.setAttribute('in', 'SourceGraphic'); feGauss.setAttribute('stdDeviation', '3'); feGauss.setAttribute('result', 'blur');
    const feFlood = document.createElementNS('http://www.w3.org/2000/svg', 'feFlood');
    feFlood.setAttribute('flood-color', col.stroke); feFlood.setAttribute('flood-opacity', '0.5'); feFlood.setAttribute('result', 'color');
    const feComp = document.createElementNS('http://www.w3.org/2000/svg', 'feComposite');
    feComp.setAttribute('in', 'color'); feComp.setAttribute('in2', 'blur'); feComp.setAttribute('operator', 'in'); feComp.setAttribute('result', 'shadow');
    const merge = document.createElementNS('http://www.w3.org/2000/svg', 'feMerge');
    const mn1 = document.createElementNS('http://www.w3.org/2000/svg', 'feMergeNode'); mn1.setAttribute('in', 'shadow');
    const mn2 = document.createElementNS('http://www.w3.org/2000/svg', 'feMergeNode'); mn2.setAttribute('in', 'SourceGraphic');
    merge.appendChild(mn1); merge.appendChild(mn2);
    filter.append(feGauss, feFlood, feComp, merge);
    defs.appendChild(filter);
  });

  state.flows.forEach((flow) => {
    const col = flowCol(flow);
    const ci = flow.colorIndex % FLOW_COLORS.length;

    flow.arrows.forEach((arrow) => {
      const from = flow.boxes[arrow.from], to = flow.boxes[arrow.to];
      if (!from || !to) return;
      const pts = getArrowPoints(from, to);
      const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
      line.setAttribute('x1', pts.x1); line.setAttribute('y1', pts.y1);
      line.setAttribute('x2', pts.x2); line.setAttribute('y2', pts.y2);
      line.setAttribute('stroke', col.light); line.setAttribute('stroke-width', '2');
      line.setAttribute('fill', 'none');
      line.setAttribute('marker-end', `url(#ah-${ci})`);
      drawLayer.appendChild(line);
    });

    flow.boxes.forEach((box, i) => {
      const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
      g.setAttribute('filter', `url(#glow-${ci})`);
      const r = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
      r.setAttribute('x', box.x); r.setAttribute('y', box.y);
      r.setAttribute('width', box.w); r.setAttribute('height', box.h);
      r.setAttribute('fill', col.fill); r.setAttribute('stroke', col.stroke);
      r.setAttribute('stroke-width', '2'); r.setAttribute('rx', '4');
      g.appendChild(r);
      drawLayer.appendChild(g);

      const labelText = box.label || `${i + 1}`;
      const tw = labelText.length * 7 + 12;
      const lbg = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
      lbg.setAttribute('x', box.x); lbg.setAttribute('y', box.y - 20);
      lbg.setAttribute('width', tw); lbg.setAttribute('height', 18);
      lbg.setAttribute('fill', col.stroke); lbg.setAttribute('rx', '3');
      drawLayer.appendChild(lbg);

      const t = document.createElementNS('http://www.w3.org/2000/svg', 'text');
      t.setAttribute('x', box.x + 6); t.setAttribute('y', box.y - 6);
      t.setAttribute('fill', '#fff');
      t.setAttribute('font-family', "'JetBrains Mono', monospace");
      t.setAttribute('font-size', '11'); t.setAttribute('font-weight', '500');
      t.setAttribute('pointer-events', 'none');
      t.textContent = labelText;
      drawLayer.appendChild(t);
    });
  });
}

// ── Geometry ──
function getArrowPoints(from, to) {
  const fc = { x: from.x + from.w / 2, y: from.y + from.h / 2 };
  const tc = { x: to.x + to.w / 2, y: to.y + to.h / 2 };
  return {
    x1: clampToEdge(fc.x, fc.y, tc.x, tc.y, from).x,
    y1: clampToEdge(fc.x, fc.y, tc.x, tc.y, from).y,
    x2: clampToEdge(tc.x, tc.y, fc.x, fc.y, to).x,
    y2: clampToEdge(tc.x, tc.y, fc.x, fc.y, to).y,
  };
}

function clampToEdge(cx, cy, tx, ty, box) {
  const dx = tx - cx, dy = ty - cy;
  if (!dx && !dy) return { x: cx, y: cy };
  let t = Infinity;
  if (dx) t = Math.min(t, (box.w / 2) / Math.abs(dx));
  if (dy) t = Math.min(t, (box.h / 2) / Math.abs(dy));
  return { x: cx + dx * t, y: cy + dy * t };
}

// ── Keyboard ──
window.addEventListener('keydown', (e) => {
  if (state.phase === 'label') return;
  if (e.key === 'Escape') {
    if (state.mode === 'draw') finishCurrentFlow();
  }
  if ((e.ctrlKey || e.metaKey) && e.key === 'z') { e.preventDefault(); undo(); }
  // Quick toggle: hold space for move
  if (e.key === ' ' && state.mode === 'draw' && !e.repeat) {
    setMode('move');
    window.__spaceHeld = true;
  }
});

window.addEventListener('keyup', (e) => {
  if (e.key === ' ' && window.__spaceHeld) {
    window.__spaceHeld = false;
    setMode('draw');
  }
});

// ── History ──
function saveHistory() {
  state.history.push({
    flows: JSON.parse(JSON.stringify(state.flows)),
    currentFlowIndex: state.currentFlowIndex,
    images: images.map(im => ({ x: im.x, y: im.y })),
  });
  if (state.history.length > 50) state.history.shift();
}

function undo() {
  if (!state.history.length) return;
  const prev = state.history.pop();
  state.flows = prev.flows;
  state.currentFlowIndex = prev.currentFlowIndex;
  state.phase = (state.flows.length > 0 && state.currentFlowIndex >= 0) ? 'box' : 'idle';
  // Restore image positions
  if (prev.images) {
    prev.images.forEach((pos, i) => {
      if (images[i]) {
        images[i].x = pos.x; images[i].y = pos.y;
        images[i].el.style.left = pos.x + 'px';
        images[i].el.style.top = pos.y + 'px';
      }
    });
  }
  labelInputWrapper.classList.remove('visible');
  renderAnnotations(); updateUI();
}

function clearAll() {
  saveHistory();
  state.flows = []; state.currentFlowIndex = -1; state.phase = 'idle';
  labelInputWrapper.classList.remove('visible');
  renderAnnotations();
  if (state.mode === 'draw') startNewFlow();
}

// ── Export ──
function getWorldBounds() {
  let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
  images.forEach(im => {
    minX = Math.min(minX, im.x); minY = Math.min(minY, im.y);
    maxX = Math.max(maxX, im.x + im.w); maxY = Math.max(maxY, im.y + im.h);
  });
  state.flows.forEach(flow => flow.boxes.forEach(box => {
    minX = Math.min(minX, box.x); minY = Math.min(minY, box.y - 22);
    maxX = Math.max(maxX, box.x + box.w); maxY = Math.max(maxY, box.y + box.h);
  }));
  if (minX === Infinity) return { x: 0, y: 0, w: 800, h: 600 };
  const pad = 40;
  return { x: minX - pad, y: minY - pad, w: maxX - minX + pad * 2, h: maxY - minY + pad * 2 };
}

function renderToCanvas() {
  const bounds = getWorldBounds();
  const scale = 2; // 2x for retina-quality export
  const canvas = document.createElement('canvas');
  canvas.width = bounds.w * scale; canvas.height = bounds.h * scale;
  const ctx = canvas.getContext('2d');
  ctx.scale(scale, scale);
  ctx.translate(-bounds.x, -bounds.y);

  // Background
  ctx.fillStyle = '#0e0e12';
  ctx.fillRect(bounds.x, bounds.y, bounds.w, bounds.h);

  // Images
  const imgDrawPromises = images.map(im => new Promise(resolve => {
    const img = new Image();
    img.onload = () => {
      ctx.drawImage(img, im.x, im.y, im.w, im.h);
      resolve();
    };
    img.onerror = resolve;
    img.src = im.dataUrl;
  }));

  return Promise.all(imgDrawPromises).then(() => {
    // Annotations
    state.flows.forEach(flow => {
      const col = flowCol(flow);

      flow.arrows.forEach(arrow => {
        const from = flow.boxes[arrow.from], to = flow.boxes[arrow.to];
        if (!from || !to) return;
        const pts = getArrowPoints(from, to);
        ctx.save();
        ctx.strokeStyle = col.light; ctx.lineWidth = 2.5;
        ctx.beginPath(); ctx.moveTo(pts.x1, pts.y1); ctx.lineTo(pts.x2, pts.y2); ctx.stroke();
        const angle = Math.atan2(pts.y2 - pts.y1, pts.x2 - pts.x1);
        ctx.fillStyle = col.light;
        ctx.beginPath(); ctx.moveTo(pts.x2, pts.y2);
        ctx.lineTo(pts.x2 - 14 * Math.cos(angle - 0.4), pts.y2 - 14 * Math.sin(angle - 0.4));
        ctx.lineTo(pts.x2 - 14 * Math.cos(angle + 0.4), pts.y2 - 14 * Math.sin(angle + 0.4));
        ctx.closePath(); ctx.fill(); ctx.restore();
      });

      flow.boxes.forEach(box => {
        ctx.save();
        ctx.shadowColor = col.glow; ctx.shadowBlur = 10;
        ctx.strokeStyle = col.stroke; ctx.lineWidth = 2.5; ctx.fillStyle = col.fill;
        roundRect(ctx, box.x, box.y, box.w, box.h, 4); ctx.fill(); ctx.stroke();
        ctx.shadowColor = 'transparent'; ctx.shadowBlur = 0;
        ctx.font = "600 13px 'DM Sans', sans-serif";
        const tw = ctx.measureText(box.label).width + 12;
        ctx.fillStyle = col.stroke;
        roundRect(ctx, box.x, box.y - 20, tw, 18, 3); ctx.fill();
        ctx.fillStyle = '#fff';
        ctx.fillText(box.label, box.x + 6, box.y - 6);
        ctx.restore();
      });
    });

    return canvas;
  });
}

async function exportImage() {
  const canvas = await renderToCanvas();
  const a = document.createElement('a');
  a.download = 'annotated-flow.png'; a.href = canvas.toDataURL('image/png'); a.click();
}

async function copyToClipboard() {
  const btn = document.getElementById('copyBtn');
  try {
    const canvas = await renderToCanvas();
    const blob = await new Promise(r => canvas.toBlob(r, 'image/png'));
    await navigator.clipboard.write([new ClipboardItem({ 'image/png': blob })]);
    btn.textContent = 'Copied!';
  } catch {
    try {
      const canvas = await renderToCanvas();
      await navigator.clipboard.writeText(canvas.toDataURL('image/png'));
      btn.textContent = 'Copied!';
    } catch { btn.textContent = 'Failed'; }
  }
  setTimeout(() => { btn.textContent = 'Copy'; }, 1500);
}

function roundRect(ctx, x, y, w, h, r) {
  ctx.beginPath();
  ctx.moveTo(x + r, y); ctx.lineTo(x + w - r, y);
  ctx.quadraticCurveTo(x + w, y, x + w, y + r);
  ctx.lineTo(x + w, y + h - r);
  ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
  ctx.lineTo(x + r, y + h);
  ctx.quadraticCurveTo(x, y + h, x, y + h - r);
  ctx.lineTo(x, y + r);
  ctx.quadraticCurveTo(x, y, x + r, y); ctx.closePath();
}

// ── Init ──
window.addEventListener('resize', () => drawGrid());
drawGrid();
updateWorldTransform();
</script>
</body>
</html>
